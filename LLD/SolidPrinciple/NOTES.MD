# SOLID Principles ‚Äì Personal Notes (Java)

These notes summarize **all five SOLID principles** with simple intuition, interview-friendly definitions, and **Java examples**. Written in a beginner-friendly way, based on real confusion points.

---

## S ‚Äì Single Responsibility Principle (SRP)

### What it means (simple words)

A class should have **only one reason to change**.

‚û°Ô∏è One class = one job

### Why we need it

If one class does many things, a change in one feature can break others.

### Bad Example (violates SRP)

```java
class UserService {
    void addUser() {
        // add user to DB
    }

    void sendEmail() {
        // send email
    }
}
```

‚ùå This class handles **user logic + email logic**.

### Good Example (follows SRP)

```java
class UserService {
    void addUser() {
        // add user to DB
    }
}

class EmailService {
    void sendEmail() {
        // send email
    }
}
```

‚úÖ Each class has **one responsibility**.

### Interview Definition

> SRP states that a class should have only one reason to change.

---

## O ‚Äì Open/Closed Principle (OCP)

### What it means (simple words)

Classes should be:

* **Open for extension**
* **Closed for modification**

‚û°Ô∏è Add new behavior **without changing existing code**.

### Real Example: Notification System

### Bad Example (violates OCP)

```java
class NotificationService {
    void send(String type) {
        if (type.equals("EMAIL")) {
            // send email
        } else if (type.equals("SMS")) {
            // send sms
        }
    }
}
```

‚ùå Every new notification type requires modifying this class.

### Good Example (follows OCP)

```java
interface Notification {
    void send();
}

class EmailNotification implements Notification {
    public void send() {
        System.out.println("Email sent");
    }
}

class SMSNotification implements Notification {
    public void send() {
        System.out.println("SMS sent");
    }
}
```

```java
class NotificationService {
    void send(Notification notification) {
        notification.send();
    }
}
```

‚úÖ Add new notification types without touching existing code.

### Interview Definition

> OCP says software entities should be open for extension but closed for modification.

---

## L ‚Äì Liskov Substitution Principle (LSP)

### What it means (very simple)

If **B is a child of A**, then we should be able to replace **A with B** without breaking the program.

‚û°Ô∏è Child class should **not surprise** parent class users.

### Core Intuition

If code works with a **parent class**, it must also work with **any child class**.

### Key Rule

Child classes must **not change the expected behavior** of parent classes.

### Interview Definition

> Objects of a superclass should be replaceable with objects of its subclasses without affecting correctness.

---

## I ‚Äì Interface Segregation Principle (ISP)

### What it means (simple words)

Don't force a class to implement methods it **does not use**.

‚û°Ô∏è Many small interfaces > one big interface

### Bad Example (violates ISP)

```java
interface Machine {
    void print();
    void scan();
    void fax();
}
```

```java
class SimplePrinter implements Machine {
    public void print() {}
    public void scan() {}
    public void fax() {
        // not supported
    }
}
```

‚ùå Forced to implement `fax()`.

### Good Example (follows ISP)

```java
interface Printer {
    void print();
}

interface Scanner {
    void scan();
}

interface Fax {
    void fax();
}
```

```java
class SimplePrinter implements Printer, Scanner {
    public void print() {}
    public void scan() {}
}
```

‚úÖ Class only implements what it needs.

### Interview Definition

> ISP states that no client should be forced to depend on methods it does not use.

---

## D ‚Äì Dependency Inversion Principle (DIP)

### This is the HARDEST one ‚Äì explained simply

### What it means

High-level modules should **not depend on low-level modules**.
Both should depend on **abstractions**.

‚û°Ô∏è Depend on **interfaces**, not concrete classes.

---

### Real Use Case: Notification System

#### Step 1: Abstraction

```java
interface Notification {
    void send(String message);
}
```

#### Step 2: Low-level modules

```java
class EmailNotification implements Notification {
    public void send(String message) {
        System.out.println("Email: " + message);
    }
}

class SMSNotification implements Notification {
    public void send(String message) {
        System.out.println("SMS: " + message);
    }
}
```

#### Step 3: High-level module

```java
class NotificationService {
    private Notification notification;

    public NotificationService(Notification notification) {
        this.notification = notification;
    }

    void notifyUser(String message) {
        notification.send(message);
    }
}
```

#### Step 4: Wiring (Main class)

```java
public class Main {
    public static void main(String[] args) {
        Notification email = new EmailNotification();
        NotificationService service1 = new NotificationService(email);
        service1.notifyUser("Hello Email");

        Notification sms = new SMSNotification();
        NotificationService service2 = new NotificationService(sms);
        service2.notifyUser("Hello SMS");
    }
}
```

### Why this is DIP

* High-level (`NotificationService`) depends on **Notification interface**
* Low-level (`Email`, `SMS`) also depend on the same interface
* Easy to add WhatsApp / Push later

### Interview Definition

> DIP states that high-level modules should not depend on low-level modules; both should depend on abstractions.

---

## Java Fundamentals Used in SOLID (Very Important)

This section explains **access modifiers**, **superclass usage**, and **interfaces vs classes** ‚Äî concepts that are essential to truly understand SOLID.

---

## Access Modifiers in Java

Access modifiers control **who can access what**.

### Types of Access Modifiers

| Modifier             | Same Class | Same Package | Subclass (diff package) | Everywhere |
| -------------------- | ---------- | ------------ | ----------------------- | ---------- |
| public               | ‚úÖ          | ‚úÖ            | ‚úÖ                       | ‚úÖ          |
| protected            | ‚úÖ          | ‚úÖ            | ‚úÖ                       | ‚ùå          |
| default (no keyword) | ‚úÖ          | ‚úÖ            | ‚ùå                       | ‚ùå          |
| private              | ‚úÖ          | ‚ùå            | ‚ùå                       | ‚ùå          |

---

### Example

```java
package a;

public class Parent {
    public int a = 1;
    protected int b = 2;
    int c = 3;        // default
    private int d = 4;
}
```

```java
package a;

class SamePackage {
    void test() {
        Parent p = new Parent();
        p.a = 1; // ‚úÖ
        p.b = 2; // ‚úÖ
        p.c = 3; // ‚úÖ
        // p.d ‚ùå private
    }
}
```

```java
package b;

class Child extends Parent {
    void test() {
        a = 1; // ‚úÖ
        b = 2; // ‚úÖ (protected works in subclass)
        // c ‚ùå default
        // d ‚ùå private
    }
}
```

### Interview Line

> `protected` is accessible within the same package and subclasses.

---

## What is a Superclass?

A **superclass** is a parent class from which another class inherits.

```java
class Vehicle {
    void move() {
        System.out.println("Vehicle moving");
    }
}

class Car extends Vehicle {
}
```

Here:

* `Vehicle` ‚Üí superclass
* `Car` ‚Üí subclass

---

## When to Use Inheritance (Superclass)

‚úÖ Use when:

* IS-A relationship exists (Car IS-A Vehicle)
* Child truly behaves like parent (LSP)

‚ùå Do NOT use when:

* Behavior is different
* You only want code reuse

üëâ Prefer **composition** over inheritance.

---

## What is `super` keyword?

Used to access **parent class constructor or methods**.

### Example

```java
class Animal {
    Animal(String name) {
        System.out.println(name);
    }
}

class Dog extends Animal {
    Dog() {
        super("Dog"); // calls parent constructor
    }
}
```

---

## Interface in Java

An **interface** defines WHAT a class should do, not HOW.

```java
interface Payment {
    void pay();
}
```

```java
class UpiPayment implements Payment {
    public void pay() {
        System.out.println("Paid via UPI");
    }
}
```

---

## Interface vs Class (VERY IMPORTANT)

| Feature              | Interface           | Class           |
| -------------------- | ------------------- | --------------- |
| Methods              | Abstract by default | Can be concrete |
| Fields               | public static final | Any access      |
| Multiple inheritance | ‚úÖ allowed           | ‚ùå not allowed   |
| Constructor          | ‚ùå no                | ‚úÖ yes           |
| Use case             | Abstraction         | Implementation  |

---

## Why Interfaces are Used in SOLID

* OCP ‚Üí extend behavior
* ISP ‚Üí split responsibilities
* DIP ‚Üí depend on abstraction

Interfaces are the **backbone of SOLID**.

---

## Updated One-Line SOLID Summary (Interview Ready)

* **S** ‚Üí One class, one job
* **O** ‚Üí Add new code, don‚Äôt modify old code
* **L** ‚Üí Child must not break parent expectations
* **I** ‚Üí Small interfaces are better
* **D** ‚Üí Depend on interfaces, not concrete classes

---

‚úÖ These notes now include **SOLID + Java fundamentals**, exactly how interviewers expect.
