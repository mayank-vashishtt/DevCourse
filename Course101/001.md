# JavaScript Object-Oriented Programming (OOP) - Complete Guide ðŸš€

From Beginner to Advanced - Everything you need to know!

---

## Table of Contents
1. [Variable Declarations (const, let, var)](#1-variable-declarations)
2. [Classes and Constructors](#2-classes-and-constructors)
3. [Encapsulation](#3-encapsulation)
4. [Inheritance](#4-inheritance)
5. [Super Keyword](#5-super-keyword)
6. [Method Overriding](#6-method-overriding)
7. [Complete Examples](#7-complete-examples)

---

## 1. Variable Declarations

### Comparison Table

| Keyword | Reassign | Redeclare | Scope | Use When |
|---------|----------|-----------|-------|----------|
| `const` | âŒ No | âŒ No | Block | Values that won't change |
| `let` | âœ… Yes | âŒ No | Block | Values that will change |
| `var` | âœ… Yes | âœ… Yes | Function | Avoid (old style) |

### Examples

```javascript
// const - Cannot reassign or redeclare
const PI = 3.14;
PI = 3.15;        // âŒ ERROR: Cannot reassign
const PI = 3.15;  // âŒ ERROR: Cannot redeclare

// let - Can reassign, cannot redeclare
let age = 25;
age = 26;         // âœ… Works (reassign)
let age = 27;     // âŒ ERROR: Cannot redeclare

// var - Can reassign and redeclare
var name = "John";
name = "Jane";    // âœ… Works (reassign)
var name = "Bob"; // âœ… Works (redeclare) - unusual!
```

**Best Practice:** Use `const` by default, `let` when you need to reassign, avoid `var`.

---

## 2. Classes and Constructors

### What is a Class?

A **class** is a blueprint for creating objects. Think of it like a cookie cutter - the class is the cutter, objects are the cookies.

### What is a Constructor?

A **constructor** is a special method that runs automatically when you create a new object. It initializes the object's properties.

### Basic Syntax

```javascript
class ClassName {
    // Constructor - runs when object is created
    constructor(parameter1, parameter2) {
        this.property1 = parameter1;
        this.property2 = parameter2;
    }
    
    // Method
    methodName() {
        // code here
    }
}

// Creating an object
const obj = new ClassName(value1, value2);
```

### Example: Person Class

```javascript
class Person {
    // Constructor - initializes properties
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // Method
    greet() {
        console.log(`Hi, I'm ${this.name} and I'm ${this.age} years old`);
    }
    
    haveBirthday() {
        this.age++;
        console.log(`Happy birthday! Now I'm ${this.age}`);
    }
}

// Creating objects
const person1 = new Person("Alice", 25);
const person2 = new Person("Bob", 30);

person1.greet();  // "Hi, I'm Alice and I'm 25 years old"
person2.greet();  // "Hi, I'm Bob and I'm 30 years old"

person1.haveBirthday();  // "Happy birthday! Now I'm 26"
```

### Key Points
- Constructor runs **automatically** when you use `new`
- Constructor **must** be named `constructor`
- `this` refers to the current object being created
- Constructor has **no return type** (returns the object automatically)

---

## 3. Encapsulation

### What is Encapsulation?

**Encapsulation** means bundling data (properties) and methods together, and **hiding** internal details. Only expose what's necessary.

**Real-world analogy:** A TV remote - you press buttons (public methods) but don't touch the circuit board (private data).

### Why Encapsulation?

âœ… **Data Protection** - Prevent invalid values  
âœ… **Validation** - Control how data is changed  
âœ… **Flexibility** - Change internal code without breaking external code  
âœ… **Security** - Hide sensitive information  

### Private Fields (`#`)

Use `#` before a property name to make it private (ES2022 feature).

```javascript
class BankAccount {
    // Private fields (cannot be accessed outside)
    #balance;
    #accountNumber;
    
    constructor(accountNumber, initialBalance) {
        this.#accountNumber = accountNumber;
        this.#balance = initialBalance;
        this.accountHolder = ""; // Public property
    }
    
    // Public methods to access private data
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            console.log(`Deposited $${amount}. New balance: $${this.#balance}`);
        } else {
            console.log("Invalid deposit amount");
        }
    }
    
    withdraw(amount) {
        if (amount > 0 && amount <= this.#balance) {
            this.#balance -= amount;
            console.log(`Withdrawn $${amount}. New balance: $${this.#balance}`);
        } else {
            console.log("Insufficient funds or invalid amount");
        }
    }
    
    getBalance() {
        return this.#balance;
    }
}

// Usage
const account = new BankAccount("12345", 1000);

account.deposit(500);   // âœ… Works - "Deposited $500. New balance: $1500"
account.withdraw(200);  // âœ… Works - "Withdrawn $200. New balance: $1300"

console.log(account.getBalance());  // âœ… 1300

// These DON'T work (and that's good for security!)
console.log(account.#balance);  // âŒ ERROR: Private field
account.#balance = 999999;      // âŒ ERROR: Private field
```

### Benefits of Encapsulation

```javascript
// WITHOUT Encapsulation - Bad!
const account = { balance: 1000 };
account.balance = -5000;  // âŒ Negative balance? Disaster!
account.balance = "banana"; // âŒ Balance is a fruit?

// WITH Encapsulation - Good!
const account = new BankAccount("12345", 1000);
account.withdraw(2000);  // âœ… "Insufficient funds" - Protected!
```

---

## 4. Inheritance

### What is Inheritance?

**Inheritance** allows a child class to inherit properties and methods from a parent class. It's like children inheriting traits from parents.

### Why Use Inheritance?

âœ… **Code Reusability** - Don't repeat yourself  
âœ… **Organization** - Create logical hierarchies  
âœ… **Extensibility** - Add new features to existing code  

### Syntax

```javascript
class ChildClass extends ParentClass {
    // child class code
}
```

### Basic Example

```javascript
// PARENT CLASS
class Animal {
    constructor(name, species) {
        this.name = name;
        this.species = species;
    }
    
    makeSound() {
        console.log(`${this.name} makes a sound`);
    }
    
    eat() {
        console.log(`${this.name} is eating`);
    }
    
    sleep() {
        console.log(`${this.name} is sleeping`);
    }
}

// CHILD CLASS
class Dog extends Animal {
    constructor(name, breed) {
        super(name, "Canine");  // Call parent constructor
        this.breed = breed;
    }
    
    // Dog-specific method
    bark() {
        console.log(`${this.name} barks: Woof! Woof!`);
    }
    
    // Override parent method
    makeSound() {
        console.log(`${this.name} barks: Woof!`);
    }
}

// ANOTHER CHILD CLASS
class Cat extends Animal {
    constructor(name, breed) {
        super(name, "Feline");
        this.breed = breed;
    }
    
    meow() {
        console.log(`${this.name} meows: Meow!`);
    }
    
    // Override parent method
    makeSound() {
        console.log(`${this.name} meows: Meow!`);
    }
}

// Usage
const dog = new Dog("Buddy", "Golden Retriever");
const cat = new Cat("Whiskers", "Persian");

// Inherited methods (from Animal)
dog.eat();    // âœ… "Buddy is eating"
dog.sleep();  // âœ… "Buddy is sleeping"
cat.eat();    // âœ… "Whiskers is eating"

// Own methods
dog.bark();   // âœ… "Buddy barks: Woof! Woof!"
cat.meow();   // âœ… "Whiskers meows: Meow!"

// Overridden method
dog.makeSound();  // "Buddy barks: Woof!" (Dog's version)
cat.makeSound();  // "Whiskers meows: Meow!" (Cat's version)
```

### Inheritance Hierarchy

```
        Animal (Parent)
       /              \
     Dog              Cat
   (Child)          (Child)
```

Dog and Cat **inherit** from Animal:
- They get `name`, `species` properties
- They get `eat()`, `sleep()`, `makeSound()` methods
- They can add their own properties and methods
- They can override parent methods

---

## 5. Super Keyword

### What is `super`?

`super` is used to call the parent class's constructor or methods from the child class.

Think of `super` as "**super parent**" - calling your parent for help!

### Two Uses of `super`

1. **`super()` in constructor** - Calls parent's constructor
2. **`super.methodName()` in methods** - Calls parent's method

### `super()` in Constructor

```javascript
class Animal {
    constructor(name, species) {
        this.name = name;
        this.species = species;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name, "Canine");  // ðŸ‘ˆ Calls Animal's constructor
        this.breed = breed;
    }
}

const dog = new Dog("Buddy", "Golden Retriever");
```

**What happens step-by-step:**

```
1. new Dog("Buddy", "Golden Retriever") is called
   â†“
2. Dog's constructor starts
   - name = "Buddy"
   - breed = "Golden Retriever"
   â†“
3. super(name, "Canine") runs
   - Calls Animal's constructor
   - Sets this.name = "Buddy"
   - Sets this.species = "Canine"
   â†“
4. Back to Dog's constructor
   - Sets this.breed = "Golden Retriever"
   â†“
5. Final object created:
   {
       name: "Buddy",
       species: "Canine",
       breed: "Golden Retriever"
   }
```

### Rules for `super()` in Constructor

âš ï¸ **MUST call `super()` BEFORE using `this`**

```javascript
// âŒ WRONG
class Dog extends Animal {
    constructor(name, breed) {
        this.breed = breed;  // ERROR! Can't use 'this' before super()
        super(name, "Canine");
    }
}

// âœ… CORRECT
class Dog extends Animal {
    constructor(name, breed) {
        super(name, "Canine");  // Call super() first
        this.breed = breed;     // Then use 'this'
    }
}
```

### `super.methodName()` in Methods

Use `super.methodName()` to call the parent's version of a method.

```javascript
class Animal {
    makeSound() {
        console.log(`${this.name} makes a sound`);
    }
    
    eat() {
        console.log(`${this.name} is eating`);
    }
}

class Dog extends Animal {
    // Call parent method, then add more
    makeSound() {
        super.makeSound();  // ðŸ‘ˆ Call parent's makeSound()
        console.log(`${this.name} also barks: Woof!`);
    }
    
    // Enhance parent's method
    eat() {
        console.log(`${this.name} wags tail`);
        super.eat();  // ðŸ‘ˆ Call parent's eat()
        console.log(`${this.name} licks bowl`);
    }
}

const dog = new Dog("Buddy", "Golden Retriever");

dog.makeSound();
// Output:
// "Buddy makes a sound"      â† from Animal (via super)
// "Buddy also barks: Woof!"  â† from Dog

dog.eat();
// Output:
// "Buddy wags tail"    â† from Dog (before)
// "Buddy is eating"    â† from Animal (via super)
// "Buddy licks bowl"   â† from Dog (after)
```

---

## 6. Method Overriding

### What is Method Overriding?

**Method Overriding** is when a child class provides its own implementation of a method that already exists in the parent class.

### Three Ways to Handle Parent Methods

#### 1. Direct Inheritance (Don't Override)

Just use the parent's method as-is.

```javascript
class Animal {
    sleep() {
        console.log(`${this.name} is sleeping`);
    }
}

class Dog extends Animal {
    // Don't define sleep() - inherit it automatically
}

const dog = new Dog("Buddy", "Golden Retriever");
dog.sleep();  // âœ… "Buddy is sleeping" (from Animal)
```

#### 2. Use `super` to Enhance

Call parent's method and add your own code.

```javascript
class Animal {
    eat() {
        console.log(`${this.name} is eating`);
    }
}

class Dog extends Animal {
    eat() {
        console.log("Tail wagging...");
        super.eat();  // ðŸ‘ˆ Call parent's version
        console.log("Finished eating!");
    }
}

const dog = new Dog("Buddy", "Golden Retriever");
dog.eat();
// Output:
// "Tail wagging..."
// "Buddy is eating"    â† parent
// "Finished eating!"
```

#### 3. Complete Override

Replace parent's method entirely (don't use `super`).

```javascript
class Animal {
    makeSound() {
        console.log(`${this.name} makes a sound`);
    }
}

class Dog extends Animal {
    makeSound() {
        console.log(`${this.name} barks: Woof!`);
        // No super.makeSound() - completely different
    }
}

const dog = new Dog("Buddy", "Golden Retriever");
dog.makeSound();  // "Buddy barks: Woof!" (only Dog's version)
```

### When to Use Each?

| Method | When to Use | Example |
|--------|-------------|---------|
| **Direct Inheritance** | Parent's method is perfect | `dog.sleep()` |
| **Use super** | Want to add to parent's behavior | `super.eat(); console.log("extra")` |
| **Complete Override** | Parent's method doesn't fit | Replace entirely |

---

## 7. Complete Examples

### Example 1: Coffee Machine (Encapsulation)

```javascript
class CoffeeMachine {
    // Private properties
    #waterLevel;
    #coffeeBeansLevel;
    
    constructor() {
        this.#waterLevel = 100;
        this.#coffeeBeansLevel = 50;
    }
    
    // Public method
    makeCoffee() {
        if (this.#waterLevel >= 10 && this.#coffeeBeansLevel >= 5) {
            this.#waterLevel -= 10;
            this.#coffeeBeansLevel -= 5;
            console.log("â˜• Coffee ready!");
            return true;
        } else {
            console.log("âŒ Not enough water or beans!");
            return false;
        }
    }
    
    refillWater(amount) {
        if (amount > 0 && amount <= 100) {
            this.#waterLevel = Math.min(this.#waterLevel + amount, 100);
            console.log(`ðŸ’§ Water refilled. Level: ${this.#waterLevel}%`);
        } else {
            console.log("âŒ Invalid amount!");
        }
    }
    
    getStatus() {
        return `Water: ${this.#waterLevel}%, Beans: ${this.#coffeeBeansLevel}%`;
    }
}

// Usage
const machine = new CoffeeMachine();
machine.makeCoffee();  // â˜• Coffee ready!
console.log(machine.getStatus());  // Water: 90%, Beans: 45%
machine.refillWater(10);  // ðŸ’§ Water refilled. Level: 100%
```

### Example 2: Vehicle System (Inheritance)

```javascript
// PARENT CLASS
class Vehicle {
    constructor(brand, model, year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }
    
    start() {
        console.log(`${this.brand} ${this.model} is starting...`);
    }
    
    stop() {
        console.log(`${this.brand} ${this.model} is stopping...`);
    }
    
    getInfo() {
        return `${this.year} ${this.brand} ${this.model}`;
    }
}

// CHILD CLASS 1
class Car extends Vehicle {
    constructor(brand, model, year, doors) {
        super(brand, model, year);
        this.doors = doors;
    }
    
    // Enhance parent method
    start() {
        console.log("Inserting key...");
        super.start();
        console.log("Ready to drive!");
    }
    
    // New method
    honk() {
        console.log("HONK HONK! ðŸš—");
    }
}

// CHILD CLASS 2
class Motorcycle extends Vehicle {
    constructor(brand, model, year, engineCC) {
        super(brand, model, year);
        this.engineCC = engineCC;
    }
    
    // Override completely
    start() {
        console.log("Kick-starting motorcycle...");
        console.log(`${this.brand} ${this.model} is revving! VROOM!`);
    }
    
    // New method
    wheelie() {
        console.log("Doing a wheelie! ðŸï¸");
    }
}

// Usage
const car = new Car("Toyota", "Camry", 2024, 4);
const bike = new Motorcycle("Honda", "CBR", 2024, 1000);

console.log(car.getInfo());  // "2024 Toyota Camry" (inherited)

car.start();
// Output:
// "Inserting key..."
// "Toyota Camry is starting..."
// "Ready to drive!"

car.honk();  // "HONK HONK! ðŸš—"

bike.start();
// Output:
// "Kick-starting motorcycle..."
// "Honda CBR is revving! VROOM!"

bike.wheelie();  // "Doing a wheelie! ðŸï¸"
```

### Example 3: All Concepts Together

```javascript
// PARENT CLASS with Encapsulation
class BankAccount {
    #balance;  // Private
    #accountNumber;  // Private
    
    constructor(accountNumber, initialBalance) {
        this.#accountNumber = accountNumber;
        this.#balance = initialBalance;
    }
    
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            console.log(`Deposited $${amount}`);
        }
    }
    
    withdraw(amount) {
        if (amount > 0 && amount <= this.#balance) {
            this.#balance -= amount;
            console.log(`Withdrawn $${amount}`);
            return true;
        }
        console.log("Insufficient funds");
        return false;
    }
    
    getBalance() {
        return this.#balance;
    }
}

// CHILD CLASS with Inheritance
class SavingsAccount extends BankAccount {
    #interestRate;  // Private
    
    constructor(accountNumber, initialBalance, interestRate) {
        super(accountNumber, initialBalance);  // Call parent constructor
        this.#interestRate = interestRate;
    }
    
    // Override with enhancement
    withdraw(amount) {
        console.log("Savings account withdrawal:");
        return super.withdraw(amount);  // Call parent's withdraw
    }
    
    // New method
    addInterest() {
        const interest = this.getBalance() * this.#interestRate;
        this.deposit(interest);
        console.log(`Interest added: $${interest}`);
    }
}

// Usage
const savings = new SavingsAccount("SAV123", 1000, 0.05);

savings.deposit(500);  // "Deposited $500"
console.log(savings.getBalance());  // 1500

savings.withdraw(200);
// Output:
// "Savings account withdrawal:"
// "Withdrawn $200"

savings.addInterest();
// Output:
// "Deposited $65"
// "Interest added: $65"

console.log(savings.getBalance());  // 1365
```

---

## Quick Reference Cheat Sheet

### Class Structure
```javascript
class ClassName {
    #privateField;           // Private property
    
    constructor(param) {
        this.publicField = param;  // Public property
        this.#privateField = 0;
    }
    
    publicMethod() {         // Public method
        // accessible everywhere
    }
    
    #privateMethod() {       // Private method
        // only accessible inside class
    }
}
```

### Inheritance Structure
```javascript
class Parent {
    constructor(param) {
        this.property = param;
    }
    
    method() {
        // code
    }
}

class Child extends Parent {
    constructor(param1, param2) {
        super(param1);       // Call parent constructor FIRST
        this.childProp = param2;
    }
    
    method() {
        super.method();      // Call parent method (optional)
        // add child code
    }
}
```

### Key Rules
1. âœ… Use `const` by default, `let` when needed, avoid `var`
2. âœ… Constructor must be named `constructor`
3. âœ… Use `#` for private fields
4. âœ… Call `super()` BEFORE using `this` in child constructor
5. âœ… Use `extends` keyword for inheritance
6. âœ… Use `super.methodName()` to call parent methods

---

## Common Mistakes to Avoid

âŒ **Using `this` before `super()` in constructor**
```javascript
// WRONG
constructor(name, breed) {
    this.breed = breed;  // Error!
    super(name);
}

// CORRECT
constructor(name, breed) {
    super(name);
    this.breed = breed;
}
```

âŒ **Accessing private fields outside class**
```javascript
const account = new BankAccount("123", 1000);
console.log(account.#balance);  // Error!
```

âŒ **Forgetting `new` keyword**
```javascript
const dog = Dog("Buddy", "Retriever");  // Wrong!
const dog = new Dog("Buddy", "Retriever");  // Correct!
```

---

## Practice Exercise

Try creating this class hierarchy:

```
        Shape (parent)
        /           \
    Circle        Rectangle
```

**Requirements:**
- Shape should have constructor for `color`
- Shape should have method `getColor()`
- Circle should add `radius` and method `getArea()`
- Rectangle should add `width`, `height` and method `getArea()`
- Use encapsulation (private fields) for radius, width, height
- Use `super` properly

**Solution at the end? Try it yourself first! ðŸ’ª**

---

## Conclusion

You've learned:
- âœ… Variable declarations (`const`, `let`, `var`)
- âœ… Classes and Constructors
- âœ… Encapsulation with private fields
- âœ… Inheritance with `extends`
- âœ… `super` keyword for constructor and methods
- âœ… Method overriding (3 ways)

**Remember:** 
- Encapsulation = Hide and protect
- Inheritance = Reuse and extend
- Super = Call parent

Keep practicing and you'll master OOP in JavaScript! ðŸŽ‰

---
