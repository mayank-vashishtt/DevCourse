# Complete Database Concepts Guide
## From Basic to Advanced with Interview Questions

---

## Table of Contents
1. [SQL vs NoSQL Databases](#sql-vs-nosql-databases)
2. [ORM (Object-Relational Mapping)](#orm-object-relational-mapping)
3. [Mongoose](#mongoose)
4. [HTTP Server](#http-server)
5. [Interview Questions](#interview-questions)

---

## SQL vs NoSQL Databases

### What is a Database?
A database is an organized collection of structured information or data, typically stored electronically in a computer system. It is managed by a Database Management System (DBMS).

### SQL Databases (Relational Databases)

#### Definition
SQL (Structured Query Language) databases are relational databases that store data in tables with predefined schemas. They use SQL for defining and manipulating data.

#### Key Characteristics
- **Structured Schema**: Tables with rows and columns
- **ACID Properties**: Atomicity, Consistency, Isolation, Durability
- **Relationships**: Foreign keys connect related tables
- **Vertical Scaling**: Typically scaled by adding more power to existing server
- **Predefined Schema**: Structure must be defined before data entry

#### Popular SQL Databases
- MySQL
- PostgreSQL
- Oracle Database
- Microsoft SQL Server
- SQLite

#### When to Use SQL
- Complex queries and reporting
- Transaction-oriented systems (banking, e-commerce)
- Data integrity is critical
- Established relationships between data entities
- ACID compliance required

#### Example SQL Structure
```sql
-- Users Table
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Orders Table
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    product_name VARCHAR(100),
    amount DECIMAL(10,2),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Query with JOIN
SELECT u.username, o.product_name, o.amount
FROM users u
INNER JOIN orders o ON u.user_id = o.user_id
WHERE u.user_id = 1;
```

### NoSQL Databases (Non-Relational Databases)

#### Definition
NoSQL databases are non-relational databases designed for distributed data storage and retrieval. They don't require fixed table schemas and avoid join operations.

#### Key Characteristics
- **Flexible Schema**: Dynamic and unstructured
- **Horizontal Scaling**: Scaled by adding more servers
- **High Performance**: Optimized for specific data models
- **Distributed**: Built for cloud computing
- **Eventually Consistent**: May sacrifice immediate consistency for availability

#### Types of NoSQL Databases

1. **Document Databases** (MongoDB, CouchDB)
   - Store data in JSON-like documents
   - Best for: Content management, catalogs, user profiles

2. **Key-Value Stores** (Redis, DynamoDB)
   - Simple key-value pairs
   - Best for: Caching, session management, real-time data

3. **Column-Family Stores** (Cassandra, HBase)
   - Store data in columns rather than rows
   - Best for: Analytics, time-series data

4. **Graph Databases** (Neo4j, ArangoDB)
   - Store data in nodes and edges
   - Best for: Social networks, recommendation engines

#### Popular NoSQL Databases
- MongoDB (Document)
- Redis (Key-Value)
- Cassandra (Column-Family)
- Neo4j (Graph)
- DynamoDB (Key-Value/Document)

#### When to Use NoSQL
- Rapid development with changing requirements
- Large volumes of unstructured data
- Horizontal scaling needs
- Real-time web applications
- Distributed systems
- Big Data applications

#### Example NoSQL Structure (MongoDB)
```javascript
// Users Collection - Document
{
    "_id": ObjectId("507f1f77bcf86cd799439011"),
    "username": "john_doe",
    "email": "john@example.com",
    "profile": {
        "age": 30,
        "location": "New York"
    },
    "orders": [
        {
            "product_name": "Laptop",
            "amount": 1299.99,
            "order_date": ISODate("2024-01-15")
        },
        {
            "product_name": "Mouse",
            "amount": 29.99,
            "order_date": ISODate("2024-01-20")
        }
    ],
    "tags": ["premium", "tech-enthusiast"],
    "created_at": ISODate("2024-01-01")
}
```

### SQL vs NoSQL: Detailed Comparison

| Feature | SQL | NoSQL |
|---------|-----|-------|
| **Data Structure** | Tables with fixed schema | Flexible, various formats |
| **Schema** | Predefined, rigid | Dynamic, flexible |
| **Scalability** | Vertical (scale up) | Horizontal (scale out) |
| **Transactions** | ACID compliant | BASE (Basically Available, Soft state, Eventually consistent) |
| **Query Language** | SQL (standardized) | Database-specific APIs |
| **Relationships** | Foreign keys, JOINs | Embedded documents or references |
| **Data Integrity** | High (enforced constraints) | Application-level enforcement |
| **Performance** | Better for complex queries | Better for simple lookups and writes |
| **Use Cases** | Financial systems, ERP | Social media, IoT, real-time apps |
| **Examples** | MySQL, PostgreSQL | MongoDB, Redis, Cassandra |

### Detailed Differences

#### 1. **Data Model**
- **SQL**: Rows and columns in tables, normalized data
- **NoSQL**: Documents, key-value pairs, graphs, or columns

#### 2. **Schema Flexibility**
- **SQL**: Schema changes require migrations and can be disruptive
- **NoSQL**: Schema-less or flexible schema, easy to modify

#### 3. **Scaling Strategy**
- **SQL**: Vertical scaling (more CPU, RAM, storage on single server)
  - Limited by hardware constraints
  - Can be expensive
- **NoSQL**: Horizontal scaling (add more servers/nodes)
  - Virtually unlimited scalability
  - Cost-effective

#### 4. **Query Complexity**
- **SQL**: Complex queries with multiple JOINs supported
- **NoSQL**: Simple queries; complex operations may require multiple queries

#### 5. **Consistency Models**
- **SQL**: Strong consistency (ACID)
  - **Atomicity**: All or nothing transactions
  - **Consistency**: Valid state transitions
  - **Isolation**: Concurrent transactions don't interfere
  - **Durability**: Committed data persists
- **NoSQL**: Eventual consistency (BASE)
  - **Basically Available**: System appears to work most of the time
  - **Soft state**: State may change over time
  - **Eventually consistent**: System will become consistent over time

#### 6. **Performance Characteristics**
- **SQL**: 
  - Excellent for complex queries
  - Can be slower with massive scale
  - Optimized for reads with proper indexing
- **NoSQL**: 
  - Extremely fast for simple operations
  - Excellent write performance
  - Optimized for specific use cases

---

## ORM (Object-Relational Mapping)

### What is ORM?

ORM (Object-Relational Mapping) is a programming technique that allows developers to interact with a relational database using object-oriented programming concepts instead of writing raw SQL queries.

### Core Concept

ORM creates a "virtual object database" that can be used from within the programming language. It maps:
- **Database tables** → **Classes/Models**
- **Table rows** → **Object instances**
- **Table columns** → **Object properties**

### Why Use ORM?

#### Advantages
1. **Database Abstraction**: Write database-agnostic code
2. **Productivity**: Less boilerplate code
3. **Security**: Protection against SQL injection
4. **Maintainability**: Cleaner, more readable code
5. **DRY Principle**: Don't Repeat Yourself
6. **Type Safety**: Compile-time checking (in typed languages)
7. **Migration Management**: Version control for database schema

#### Disadvantages
1. **Performance Overhead**: Additional abstraction layer
2. **Learning Curve**: Need to learn ORM-specific patterns
3. **Complex Queries**: Some complex SQL queries are harder in ORM
4. **Hidden Operations**: May generate inefficient queries
5. **Flexibility Loss**: Less control over exact SQL execution

### Popular ORMs

#### JavaScript/TypeScript
- **Sequelize** (SQL databases)
- **TypeORM** (SQL databases)
- **Prisma** (SQL databases)
- **Mongoose** (MongoDB - technically ODM)

#### Python
- **SQLAlchemy**
- **Django ORM**
- **Peewee**

#### Java
- **Hibernate**
- **JPA (Java Persistence API)**

#### Ruby
- **Active Record** (Rails)

#### PHP
- **Eloquent** (Laravel)
- **Doctrine**

#### C#
- **Entity Framework**
- **Dapper**

### How ORM Works

#### Without ORM (Raw SQL)
```javascript
const mysql = require('mysql');
const connection = mysql.createConnection({
    host: 'localhost',
    user: 'root',
    password: 'password',
    database: 'myapp'
});

// Create
connection.query(
    'INSERT INTO users (username, email) VALUES (?, ?)',
    ['john_doe', 'john@example.com'],
    (error, results) => {
        if (error) throw error;
        console.log('User created:', results.insertId);
    }
);

// Read
connection.query(
    'SELECT * FROM users WHERE user_id = ?',
    [1],
    (error, results) => {
        if (error) throw error;
        console.log('User:', results[0]);
    }
);

// Update
connection.query(
    'UPDATE users SET email = ? WHERE user_id = ?',
    ['newemail@example.com', 1],
    (error, results) => {
        if (error) throw error;
        console.log('Updated rows:', results.affectedRows);
    }
);

// Delete
connection.query(
    'DELETE FROM users WHERE user_id = ?',
    [1],
    (error, results) => {
        if (error) throw error;
        console.log('Deleted rows:', results.affectedRows);
    }
);
```

#### With ORM (Sequelize Example)
```javascript
const { Sequelize, DataTypes } = require('sequelize');
const sequelize = new Sequelize('myapp', 'root', 'password', {
    host: 'localhost',
    dialect: 'mysql'
});

// Define Model
const User = sequelize.define('User', {
    user_id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    username: {
        type: DataTypes.STRING,
        allowNull: false
    },
    email: {
        type: DataTypes.STRING,
        unique: true
    }
});

// Create
const createUser = async () => {
    const user = await User.create({
        username: 'john_doe',
        email: 'john@example.com'
    });
    console.log('User created:', user.user_id);
};

// Read
const getUser = async () => {
    const user = await User.findByPk(1);
    console.log('User:', user);
};

// Update
const updateUser = async () => {
    const user = await User.findByPk(1);
    user.email = 'newemail@example.com';
    await user.save();
    console.log('User updated');
};

// Delete
const deleteUser = async () => {
    const user = await User.findByPk(1);
    await user.destroy();
    console.log('User deleted');
};
```

### ORM Patterns and Concepts

#### 1. Active Record Pattern
The model class contains both data and behavior.

```javascript
class User extends Model {
    static async findByEmail(email) {
        return await this.findOne({ where: { email } });
    }
    
    async updateProfile(data) {
        this.username = data.username;
        await this.save();
    }
}
```

#### 2. Data Mapper Pattern
Separate data access from business logic.

```javascript
// Entity
class User {
    constructor(username, email) {
        this.username = username;
        this.email = email;
    }
}

// Repository
class UserRepository {
    async save(user) {
        // Save logic
    }
    
    async findById(id) {
        // Find logic
    }
}
```

#### 3. Relationships

```javascript
// One-to-Many
User.hasMany(Order, { foreignKey: 'user_id' });
Order.belongsTo(User, { foreignKey: 'user_id' });

// Many-to-Many
User.belongsToMany(Role, { through: 'UserRoles' });
Role.belongsToMany(User, { through: 'UserRoles' });

// Querying with relationships
const userWithOrders = await User.findByPk(1, {
    include: [Order]
});
```

#### 4. Migrations

```javascript
// Migration file: 20240101_create_users.js
module.exports = {
    up: async (queryInterface, Sequelize) => {
        await queryInterface.createTable('users', {
            user_id: {
                type: Sequelize.INTEGER,
                primaryKey: true,
                autoIncrement: true
            },
            username: {
                type: Sequelize.STRING,
                allowNull: false
            },
            email: {
                type: Sequelize.STRING,
                unique: true
            },
            created_at: {
                type: Sequelize.DATE,
                defaultValue: Sequelize.NOW
            }
        });
    },
    down: async (queryInterface) => {
        await queryInterface.dropTable('users');
    }
};
```

### Advanced ORM Concepts

#### Query Optimization
```javascript
// Eager Loading (prevents N+1 queries)
const users = await User.findAll({
    include: [Order]
});

// Lazy Loading
const user = await User.findByPk(1);
const orders = await user.getOrders();

// Select specific fields
const users = await User.findAll({
    attributes: ['username', 'email']
});
```

#### Transactions
```javascript
const t = await sequelize.transaction();

try {
    const user = await User.create({
        username: 'john_doe',
        email: 'john@example.com'
    }, { transaction: t });
    
    await Order.create({
        user_id: user.id,
        amount: 100
    }, { transaction: t });
    
    await t.commit();
} catch (error) {
    await t.rollback();
    throw error;
}
```

#### Hooks/Lifecycle Events
```javascript
User.beforeCreate((user) => {
    user.password = hashPassword(user.password);
});

User.afterCreate((user) => {
    sendWelcomeEmail(user.email);
});
```

---

## Mongoose

### What is Mongoose?

Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js. It provides a schema-based solution to model application data and includes built-in type casting, validation, query building, and business logic hooks.

**Note**: While Mongoose is technically an ODM (Object-Document Mapper) for MongoDB, it serves the same purpose as an ORM for relational databases.

### Why Mongoose?

MongoDB is schema-less, but in real applications, we often want:
- Data validation
- Type casting
- Business logic
- Relationships between data
- Middleware/hooks

Mongoose provides all of these features.

### Installing Mongoose

```bash
npm install mongoose
```

### Basic Setup

```javascript
const mongoose = require('mongoose');

// Connect to MongoDB
mongoose.connect('mongodb://localhost:27017/myapp', {
    useNewUrlParser: true,
    useUnifiedTopology: true
})
.then(() => console.log('MongoDB connected'))
.catch(err => console.error('MongoDB connection error:', err));

// Get connection
const db = mongoose.connection;

db.on('error', console.error.bind(console, 'connection error:'));
db.once('open', () => {
    console.log('Connected to MongoDB');
});
```

### Core Concepts

#### 1. Schema

A Schema defines the structure of documents within a collection.

```javascript
const userSchema = new mongoose.Schema({
    username: {
        type: String,
        required: [true, 'Username is required'],
        unique: true,
        trim: true,
        minlength: 3,
        maxlength: 50
    },
    email: {
        type: String,
        required: true,
        unique: true,
        lowercase: true,
        match: [/^\S+@\S+\.\S+$/, 'Invalid email format']
    },
    password: {
        type: String,
        required: true,
        minlength: 6
    },
    age: {
        type: Number,
        min: 0,
        max: 120
    },
    isActive: {
        type: Boolean,
        default: true
    },
    role: {
        type: String,
        enum: ['user', 'admin', 'moderator'],
        default: 'user'
    },
    profile: {
        bio: String,
        avatar: String,
        location: {
            city: String,
            country: String
        }
    },
    tags: [String],
    createdAt: {
        type: Date,
        default: Date.now
    }
}, {
    timestamps: true // Adds createdAt and updatedAt automatically
});
```

#### 2. Schema Types

```javascript
// Basic Types
const exampleSchema = new mongoose.Schema({
    stringField: String,
    numberField: Number,
    dateField: Date,
    booleanField: Boolean,
    arrayField: [String],
    objectField: {
        nested: String
    },
    
    // Special Types
    objectId: mongoose.Schema.Types.ObjectId,
    mixedType: mongoose.Schema.Types.Mixed,
    bufferType: Buffer,
    mapType: Map,
    decimalType: mongoose.Schema.Types.Decimal128
});
```

#### 3. Model

A Model is a compiled version of a Schema. It provides an interface to interact with the database.

```javascript
const User = mongoose.model('User', userSchema);

// Model is used to create, read, update, delete documents
```

### CRUD Operations with Mongoose

#### Create

```javascript
// Method 1: Using constructor + save()
const createUser1 = async () => {
    const user = new User({
        username: 'john_doe',
        email: 'john@example.com',
        password: 'password123',
        age: 30
    });
    
    try {
        const savedUser = await user.save();
        console.log('User created:', savedUser);
    } catch (error) {
        console.error('Error:', error.message);
    }
};

// Method 2: Using create()
const createUser2 = async () => {
    try {
        const user = await User.create({
            username: 'jane_doe',
            email: 'jane@example.com',
            password: 'password123'
        });
        console.log('User created:', user);
    } catch (error) {
        console.error('Error:', error.message);
    }
};

// Method 3: Insert many
const createMultipleUsers = async () => {
    const users = await User.insertMany([
        { username: 'user1', email: 'user1@example.com', password: 'pass1' },
        { username: 'user2', email: 'user2@example.com', password: 'pass2' }
    ]);
    console.log('Users created:', users.length);
};
```

#### Read

```javascript
// Find all
const findAllUsers = async () => {
    const users = await User.find();
    console.log('All users:', users);
};

// Find with conditions
const findUsers = async () => {
    const users = await User.find({ isActive: true, age: { $gte: 18 } });
    console.log('Active adult users:', users);
};

// Find one
const findOneUser = async () => {
    const user = await User.findOne({ email: 'john@example.com' });
    console.log('User:', user);
};

// Find by ID
const findUserById = async (id) => {
    const user = await User.findById(id);
    console.log('User:', user);
};

// Find with specific fields
const findUsersWithFields = async () => {
    const users = await User.find()
        .select('username email') // Include only these fields
        .select('-password'); // Exclude password
    console.log('Users:', users);
};

// Find with sorting and pagination
const findUsersWithOptions = async () => {
    const users = await User.find()
        .sort({ createdAt: -1 }) // Sort by newest first
        .limit(10) // Limit to 10 results
        .skip(20); // Skip first 20 (page 3)
    console.log('Users:', users);
};
```

#### Update

```javascript
// Method 1: Find and update
const updateUser1 = async (id) => {
    const user = await User.findById(id);
    user.email = 'newemail@example.com';
    user.age = 31;
    await user.save();
    console.log('Updated user:', user);
};

// Method 2: findByIdAndUpdate
const updateUser2 = async (id) => {
    const user = await User.findByIdAndUpdate(
        id,
        { email: 'updated@example.com', age: 32 },
        { new: true, runValidators: true } // Return updated doc, run validators
    );
    console.log('Updated user:', user);
};

// Method 3: updateOne
const updateUser3 = async () => {
    const result = await User.updateOne(
        { username: 'john_doe' },
        { $set: { isActive: false } }
    );
    console.log('Modified count:', result.modifiedCount);
};

// Method 4: updateMany
const updateMultipleUsers = async () => {
    const result = await User.updateMany(
        { age: { $lt: 18 } },
        { $set: { role: 'minor' } }
    );
    console.log('Modified count:', result.modifiedCount);
};
```

#### Delete

```javascript
// Method 1: findByIdAndDelete
const deleteUser1 = async (id) => {
    const user = await User.findByIdAndDelete(id);
    console.log('Deleted user:', user);
};

// Method 2: deleteOne
const deleteUser2 = async () => {
    const result = await User.deleteOne({ username: 'john_doe' });
    console.log('Deleted count:', result.deletedCount);
};

// Method 3: deleteMany
const deleteMultipleUsers = async () => {
    const result = await User.deleteMany({ isActive: false });
    console.log('Deleted count:', result.deletedCount);
};
```

### Advanced Mongoose Features

#### 1. Validation

```javascript
const productSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Product name is required'],
        minlength: [3, 'Name must be at least 3 characters'],
        maxlength: [100, 'Name cannot exceed 100 characters']
    },
    price: {
        type: Number,
        required: true,
        min: [0, 'Price cannot be negative'],
        validate: {
            validator: function(v) {
                return v % 1 !== 0 ? v.toFixed(2) === v.toString() : true;
            },
            message: 'Price must have at most 2 decimal places'
        }
    },
    email: {
        type: String,
        validate: {
            validator: function(v) {
                return /^\S+@\S+\.\S+$/.test(v);
            },
            message: props => `${props.value} is not a valid email!`
        }
    }
});
```

#### 2. Middleware (Hooks)

```javascript
// Pre-save middleware
userSchema.pre('save', async function(next) {
    // 'this' refers to the document
    if (this.isModified('password')) {
        const bcrypt = require('bcrypt');
        this.password = await bcrypt.hash(this.password, 10);
    }
    next();
});

// Post-save middleware
userSchema.post('save', function(doc) {
    console.log(`${doc.username} has been saved`);
});

// Pre-remove middleware
userSchema.pre('remove', async function(next) {
    // Clean up related data
    await Order.deleteMany({ userId: this._id });
    next();
});

// Query middleware
userSchema.pre(/^find/, function(next) {
    // Exclude inactive users from all find queries
    this.find({ isActive: { $ne: false } });
    next();
});
```

#### 3. Virtual Properties

```javascript
userSchema.virtual('fullName').get(function() {
    return `${this.firstName} ${this.lastName}`;
});

userSchema.virtual('fullName').set(function(name) {
    const parts = name.split(' ');
    this.firstName = parts[0];
    this.lastName = parts[1];
});

// Enable virtuals in JSON output
userSchema.set('toJSON', { virtuals: true });
userSchema.set('toObject', { virtuals: true });
```

#### 4. Instance Methods

```javascript
userSchema.methods.comparePassword = async function(candidatePassword) {
    const bcrypt = require('bcrypt');
    return await bcrypt.compare(candidatePassword, this.password);
};

userSchema.methods.generateAuthToken = function() {
    const jwt = require('jsonwebtoken');
    return jwt.sign({ _id: this._id }, 'secret_key');
};

// Usage
const user = await User.findOne({ email: 'john@example.com' });
const isMatch = await user.comparePassword('password123');
const token = user.generateAuthToken();
```

#### 5. Static Methods

```javascript
userSchema.statics.findByEmail = function(email) {
    return this.findOne({ email: email.toLowerCase() });
};

userSchema.statics.findAdmins = function() {
    return this.find({ role: 'admin' });
};

// Usage
const user = await User.findByEmail('john@example.com');
const admins = await User.findAdmins();
```

#### 6. Query Helpers

```javascript
userSchema.query.byAge = function(age) {
    return this.where({ age: age });
};

userSchema.query.active = function() {
    return this.where({ isActive: true });
};

// Usage
const users = await User.find().byAge(30).active();
```

#### 7. Population (Relationships)

```javascript
// Define schemas with references
const authorSchema = new mongoose.Schema({
    name: String,
    email: String
});

const bookSchema = new mongoose.Schema({
    title: String,
    author: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Author'
    },
    publishedDate: Date
});

const Author = mongoose.model('Author', authorSchema);
const Book = mongoose.model('Book', bookSchema);

// Create documents
const author = await Author.create({ name: 'John Doe', email: 'john@example.com' });
const book = await Book.create({ 
    title: 'My Book', 
    author: author._id 
});

// Populate reference
const bookWithAuthor = await Book.findById(book._id).populate('author');
console.log(bookWithAuthor.author.name); // 'John Doe'

// Populate with specific fields
const bookWithAuthorName = await Book.findById(book._id)
    .populate('author', 'name'); // Only populate name field

// Populate nested references
const postSchema = new mongoose.Schema({
    title: String,
    author: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    comments: [{
        user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
        text: String
    }]
});

const post = await Post.findById(id)
    .populate('author')
    .populate('comments.user');
```

#### 8. Indexes

```javascript
// Single field index
userSchema.index({ email: 1 });

// Compound index
userSchema.index({ username: 1, email: 1 });

// Unique index
userSchema.index({ email: 1 }, { unique: true });

// Text index for search
userSchema.index({ username: 'text', bio: 'text' });

// TTL index (document expires after certain time)
sessionSchema.index({ createdAt: 1 }, { expireAfterSeconds: 3600 });
```

#### 9. Aggregation

```javascript
// Group users by age
const stats = await User.aggregate([
    {
        $group: {
            _id: '$age',
            count: { $sum: 1 },
            avgAge: { $avg: '$age' }
        }
    },
    {
        $sort: { count: -1 }
    }
]);

// Complex aggregation pipeline
const results = await Order.aggregate([
    {
        $match: { status: 'completed' }
    },
    {
        $lookup: {
            from: 'users',
            localField: 'userId',
            foreignField: '_id',
            as: 'user'
        }
    },
    {
        $unwind: '$user'
    },
    {
        $group: {
            _id: '$user._id',
            totalSpent: { $sum: '$amount' },
            orderCount: { $sum: 1 }
        }
    },
    {
        $sort: { totalSpent: -1 }
    },
    {
        $limit: 10
    }
]);
```

#### 10. Transactions

```javascript
const session = await mongoose.startSession();
session.startTransaction();

try {
    const user = await User.create([{
        username: 'john_doe',
        email: 'john@example.com'
    }], { session });
    
    await Order.create([{
        userId: user[0]._id,
        amount: 100
    }], { session });
    
    await session.commitTransaction();
    console.log('Transaction successful');
} catch (error) {
    await session.abortTransaction();
    console.error('Transaction failed:', error);
} finally {
    session.endSession();
}
```

### Mongoose Best Practices

1. **Always use lean() for read-only queries**
```javascript
const users = await User.find().lean(); // Returns plain JavaScript objects
```

2. **Use select() to limit fields**
```javascript
const users = await User.find().select('-password -__v');
```

3. **Create indexes for frequently queried fields**
```javascript
userSchema.index({ email: 1 }, { unique: true });
```

4. **Use virtuals for computed properties**
```javascript
userSchema.virtual('fullName').get(function() {
    return `${this.firstName} ${this.lastName}`;
});
```

5. **Implement proper error handling**
```javascript
try {
    const user = await User.create(userData);
} catch (error) {
    if (error.code === 11000) {
        // Duplicate key error
        console.error('Email already exists');
    } else if (error.name === 'ValidationError') {
        // Validation error
        console.error('Validation failed:', error.message);
    }
}
```

---

## HTTP Server

### What is an HTTP Server?

An HTTP (Hypertext Transfer Protocol) server is a software application that accepts HTTP requests from clients (like web browsers) and serves HTTP responses along with optional data content (like HTML pages, images, JSON data).

### How HTTP Works

HTTP follows a request-response model:
1. **Client** sends an HTTP request to the server
2. **Server** processes the request
3. **Server** sends an HTTP response back to the client

### HTTP Request Components

```
GET /api/users/123 HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Accept: application/json
Authorization: Bearer token123
Content-Type: application/json

{
  "data": "request body (for POST/PUT)"
}
```

**Components:**
- **Method**: GET, POST, PUT, DELETE, PATCH, etc.
- **Path**: /api/users/123
- **Headers**: Metadata about the request
- **Body**: Data sent with request (POST, PUT, PATCH)

### HTTP Response Components

```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 58
Set-Cookie: session=abc123

{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com"
}
```

**Components:**
- **Status Code**: 200, 404, 500, etc.
- **Headers**: Metadata about the response
- **Body**: Data returned to client

### HTTP Methods

| Method | Purpose | Has Body | Idempotent | Safe |
|--------|---------|----------|------------|------|
| **GET** | Retrieve resource | No | Yes | Yes |
| **POST** | Create resource | Yes | No | No |
| **PUT** | Update/Replace resource | Yes | Yes | No |
| **PATCH** | Partially update resource | Yes | No | No |
| **DELETE** | Delete resource | No | Yes | No |
| **HEAD** | Get headers only | No | Yes | Yes |
| **OPTIONS** | Get allowed methods | No | Yes | Yes |

**Idempotent**: Multiple identical requests have the same effect as a single request
**Safe**: Request doesn't modify server state

### HTTP Status Codes

#### 1xx - Informational
- **100 Continue**: Server received request headers, client should proceed

#### 2xx - Success
- **200 OK**: Request succeeded
- **201 Created**: Resource created successfully
- **204 No Content**: Request succeeded, no content to return
- **202 Accepted**: Request accepted for processing

#### 3xx - Redirection
- **301 Moved Permanently**: Resource permanently moved
- **302 Found**: Temporary redirect
- **304 Not Modified**: Resource not modified (caching)

#### 4xx - Client Errors
- **400 Bad Request**: Invalid request syntax
- **401 Unauthorized**: Authentication required
- **403 Forbidden**: No permission to access
- **404 Not Found**: Resource doesn't exist
- **405 Method Not Allowed**: HTTP method not supported
- **409 Conflict**: Request conflicts with server state
- **422 Unprocessable Entity**: Validation error
- **429 Too Many Requests**: Rate limit exceeded

#### 5xx - Server Errors
- **500 Internal Server Error**: Generic server error
- **502 Bad Gateway**: Invalid response from upstream server
- **503 Service Unavailable**: Server temporarily unavailable
- **504 Gateway Timeout**: Upstream server timeout

### Creating HTTP Servers

#### 1. Node.js Built-in HTTP Module

```javascript
const http = require('http');

const server = http.createServer((req, res) => {
    // Parse URL and method
    const { method, url } = req;
    
    // Set response headers
    res.setHeader('Content-Type', 'application/json');
    
    // Route handling
    if (url === '/api/users' && method === 'GET') {
        res.statusCode = 200;
        res.end(JSON.stringify({
            users: [
                { id: 1, name: 'John' },
                { id: 2, name: 'Jane' }
            ]
        }));
    } else if (url === '/api/users' && method === 'POST') {
        let body = '';
        
        // Collect request body
        req.on('data', chunk => {
            body += chunk.toString();
        });
        
        req.on('end', () => {
            const newUser = JSON.parse(body);
            res.statusCode = 201;
            res.end(JSON.stringify({
                message: 'User created',
                user: newUser
            }));
        });
    } else {
        res.statusCode = 404;
        res.end(JSON.stringify({
            error: 'Not Found'
        }));
    }
});

const PORT = 3000;
server.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});
```

#### 2. Express.js Framework

Express is the most popular Node.js web framework that simplifies HTTP server creation.

```javascript
const express = require('express');
const app = express();

// Middleware
app.use(express.json()); // Parse JSON bodies
app.use(express.urlencoded({ extended: true })); // Parse URL-encoded bodies

// Logging middleware
app.use((req, res, next) => {
    console.log(`${req.method} ${req.url}`);
    next();
});

// Routes
app.get('/', (req, res) => {
    res.send('Hello World!');
});

app.get('/api/users', (req, res) => {
    res.json({
        users: [
            { id: 1, name: 'John' },
            { id: 2, name: 'Jane' }
        ]
    });
});

app.get('/api/users/:id', (req, res) => {
    const userId = req.params.id;
    res.json({
        user: { id: userId, name: 'John' }
    });
});

app.post('/api/users', (req, res) => {
    const newUser = req.body;
    res.status(201).json({
        message: 'User created',
        user: newUser
    });
});

app.put('/api/users/:id', (req, res) => {
    const userId = req.params.id;
    const updatedData = req.body;
    res.json({
        message: 'User updated',
        user: { id: userId, ...updatedData }
    });
});

app.delete('/api/users/:id', (req, res) => {
    const userId = req.params.id;
    res.json({
        message: 'User deleted',
        userId: userId
    });
});

// Error handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({
        error: 'Something went wrong!'
    });
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});
```

### Express Middleware

Middleware functions have access to the request, response, and the next middleware function.

```javascript
// Application-level middleware
app.use((req, res, next) => {
    req.timestamp = Date.now();
    next();
});

// Router-level middleware
const router = express.Router();
router.use((req, res, next) => {
    console.log('Router middleware');
    next();
});

// Built-in middleware
app.use(express.json());
app.use(express.static('public'));

// Third-party middleware
const cors = require('cors');
app.use(cors());

const morgan = require('morgan');
app.use(morgan('dev'));

// Error-handling middleware (must have 4 parameters)
app.use((err, req, res, next) => {
    res.status(err.status || 500).json({
        error: err.message
    });
});
```

### RESTful API Design

REST (Representational State Transfer) is an architectural style for designing networked applications.

#### REST Principles

1. **Client-Server Architecture**: Separation of concerns
2. **Stateless**: Each request contains all necessary information
3. **Cacheable**: Responses can be cached
4. **Uniform Interface**: Consistent URL patterns
5. **Layered System**: Architecture composed of hierarchical layers

#### RESTful URL Patterns

```javascript
// Collection of resources
GET    /api/users           // Get all users
POST   /api/users           // Create new user

// Single resource
GET    /api/users/:id       // Get specific user
PUT    /api/users/:id       // Update entire user
PATCH  /api/users/:id       // Partially update user
DELETE /api/users/:id       // Delete user

// Nested resources
GET    /api/users/:id/orders        // Get user's orders
POST   /api/users/:id/orders        // Create order for user
GET    /api/users/:id/orders/:orderId  // Get specific order

// Filtering, sorting, pagination
GET    /api/users?role=admin&sort=name&page=2&limit=10
GET    /api/products?category=electronics&minPrice=100&maxPrice=500
```

#### Complete RESTful API Example

```javascript
const express = require('express');
const app = express();

app.use(express.json());

// In-memory database (for demonstration)
let users = [
    { id: 1, name: 'John Doe', email: 'john@example.com', role: 'user' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'admin' }
];
let nextId = 3;

// GET /api/users - Get all users with filtering and pagination
app.get('/api/users', (req, res) => {
    const { role, page = 1, limit = 10, sort = 'name' } = req.query;
    
    let filteredUsers = [...users];
    
    // Filter by role
    if (role) {
        filteredUsers = filteredUsers.filter(u => u.role === role);
    }
    
    // Sort
    filteredUsers.sort((a, b) => {
        return a[sort] > b[sort] ? 1 : -1;
    });
    
    // Pagination
    const startIndex = (page - 1) * limit;
    const endIndex = page * limit;
    const paginatedUsers = filteredUsers.slice(startIndex, endIndex);
    
    res.json({
        total: filteredUsers.length,
        page: parseInt(page),
        limit: parseInt(limit),
        data: paginatedUsers
    });
});

// GET /api/users/:id - Get single user
app.get('/api/users/:id', (req, res) => {
    const user = users.find(u => u.id === parseInt(req.params.id));
    
    if (!user) {
        return res.status(404).json({
            error: 'User not found'
        });
    }
    
    res.json(user);
});

// POST /api/users - Create new user
app.post('/api/users', (req, res) => {
    const { name, email, role = 'user' } = req.body;
    
    // Validation
    if (!name || !email) {
        return res.status(400).json({
            error: 'Name and email are required'
        });
    }
    
    // Check for duplicate email
    if (users.find(u => u.email === email)) {
        return res.status(409).json({
            error: 'Email already exists'
        });
    }
    
    const newUser = {
        id: nextId++,
        name,
        email,
        role
    };
    
    users.push(newUser);
    
    res.status(201).json(newUser);
});

// PUT /api/users/:id - Update entire user
app.put('/api/users/:id', (req, res) => {
    const userId = parseInt(req.params.id);
    const userIndex = users.findIndex(u => u.id === userId);
    
    if (userIndex === -1) {
        return res.status(404).json({
            error: 'User not found'
        });
    }
    
    const { name, email, role } = req.body;
    
    if (!name || !email || !role) {
        return res.status(400).json({
            error: 'Name, email, and role are required'
        });
    }
    
    users[userIndex] = {
        id: userId,
        name,
        email,
        role
    };
    
    res.json(users[userIndex]);
});

// PATCH /api/users/:id - Partially update user
app.patch('/api/users/:id', (req, res) => {
    const userId = parseInt(req.params.id);
    const user = users.find(u => u.id === userId);
    
    if (!user) {
        return res.status(404).json({
            error: 'User not found'
        });
    }
    
    // Update only provided fields
    const { name, email, role } = req.body;
    if (name) user.name = name;
    if (email) user.email = email;
    if (role) user.role = role;
    
    res.json(user);
});

// DELETE /api/users/:id - Delete user
app.delete('/api/users/:id', (req, res) => {
    const userId = parseInt(req.params.id);
    const userIndex = users.findIndex(u => u.id === userId);
    
    if (userIndex === -1) {
        return res.status(404).json({
            error: 'User not found'
        });
    }
    
    users.splice(userIndex, 1);
    
    res.status(204).send(); // No content
});

app.listen(3000, () => {
    console.log('Server running on http://localhost:3000');
});
```

### Advanced HTTP Server Concepts

#### 1. Authentication & Authorization

```javascript
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

const SECRET_KEY = 'your-secret-key';

// Register
app.post('/api/register', async (req, res) => {
    const { username, password, email } = req.body;
    
    const hashedPassword = await bcrypt.hash(password, 10);
    
    const user = {
        id: nextId++,
        username,
        email,
        password: hashedPassword
    };
    
    users.push(user);
    
    res.status(201).json({
        message: 'User registered successfully'
    });
});

// Login
app.post('/api/login', async (req, res) => {
    const { email, password } = req.body;
    
    const user = users.find(u => u.email === email);
    
    if (!user) {
        return res.status(401).json({
            error: 'Invalid credentials'
        });
    }
    
    const isMatch = await bcrypt.compare(password, user.password);
    
    if (!isMatch) {
        return res.status(401).json({
            error: 'Invalid credentials'
        });
    }
    
    const token = jwt.sign(
        { id: user.id, email: user.email },
        SECRET_KEY,
        { expiresIn: '24h' }
    );
    
    res.json({
        token,
        user: {
            id: user.id,
            username: user.username,
            email: user.email
        }
    });
});

// Authentication middleware
const authenticate = (req, res, next) => {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
        return res.status(401).json({
            error: 'No token provided'
        });
    }
    
    try {
        const decoded = jwt.verify(token, SECRET_KEY);
        req.user = decoded;
        next();
    } catch (error) {
        res.status(401).json({
            error: 'Invalid token'
        });
    }
};

// Protected route
app.get('/api/profile', authenticate, (req, res) => {
    const user = users.find(u => u.id === req.user.id);
    res.json(user);
});

// Authorization middleware
const authorize = (...roles) => {
    return (req, res, next) => {
        if (!roles.includes(req.user.role)) {
            return res.status(403).json({
                error: 'Insufficient permissions'
            });
        }
        next();
    };
};

// Admin-only route
app.delete('/api/users/:id', authenticate, authorize('admin'), (req, res) => {
    // Delete user logic
});
```

#### 2. Request Validation

```javascript
const { body, param, query, validationResult } = require('express-validator');

app.post('/api/users',
    [
        body('name')
            .notEmpty().withMessage('Name is required')
            .isLength({ min: 3 }).withMessage('Name must be at least 3 characters'),
        body('email')
            .isEmail().withMessage('Invalid email format')
            .normalizeEmail(),
        body('age')
            .optional()
            .isInt({ min: 0, max: 120 }).withMessage('Age must be between 0 and 120')
    ],
    (req, res) => {
        const errors = validationResult(req);
        
        if (!errors.isEmpty()) {
            return res.status(400).json({
                errors: errors.array()
            });
        }
        
        // Proceed with user creation
        const newUser = req.body;
        users.push(newUser);
        res.status(201).json(newUser);
    }
);
```

#### 3. Rate Limiting

```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
    message: 'Too many requests, please try again later'
});

app.use('/api/', limiter);

// Specific limiter for login
const loginLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 5,
    message: 'Too many login attempts, please try again later'
});

app.post('/api/login', loginLimiter, (req, res) => {
    // Login logic
});
```

#### 4. CORS (Cross-Origin Resource Sharing)

```javascript
const cors = require('cors');

// Enable all CORS requests
app.use(cors());

// Configure CORS
app.use(cors({
    origin: 'http://example.com',
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    credentials: true,
    maxAge: 86400
}));

// Multiple origins
const whitelist = ['http://example1.com', 'http://example2.com'];
app.use(cors({
    origin: function (origin, callback) {
        if (whitelist.indexOf(origin) !== -1 || !origin) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    }
}));
```

#### 5. File Upload

```javascript
const multer = require('multer');
const path = require('path');

// Configure storage
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'uploads/');
    },
    filename: (req, file, cb) => {
        cb(null, Date.now() + path.extname(file.originalname));
    }
});

// File filter
const fileFilter = (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
    
    if (allowedTypes.includes(file.mimetype)) {
        cb(null, true);
    } else {
        cb(new Error('Invalid file type'), false);
    }
};

const upload = multer({
    storage: storage,
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
    fileFilter: fileFilter
});

// Single file upload
app.post('/api/upload', upload.single('avatar'), (req, res) => {
    if (!req.file) {
        return res.status(400).json({
            error: 'No file uploaded'
        });
    }
    
    res.json({
        message: 'File uploaded successfully',
        filename: req.file.filename,
        path: req.file.path
    });
});

// Multiple files upload
app.post('/api/upload-multiple', upload.array('photos', 10), (req, res) => {
    res.json({
        message: 'Files uploaded successfully',
        files: req.files.map(f => ({
            filename: f.filename,
            path: f.path
        }))
    });
});
```

#### 6. WebSockets (Real-time Communication)

```javascript
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = socketIo(server);

// Socket.io connection
io.on('connection', (socket) => {
    console.log('New client connected:', socket.id);
    
    // Listen for messages
    socket.on('message', (data) => {
        console.log('Message received:', data);
        
        // Broadcast to all clients
        io.emit('message', data);
    });
    
    // Join room
    socket.on('join-room', (room) => {
        socket.join(room);
        socket.to(room).emit('user-joined', socket.id);
    });
    
    // Send to specific room
    socket.on('room-message', ({ room, message }) => {
        io.to(room).emit('message', message);
    });
    
    // Disconnect
    socket.on('disconnect', () => {
        console.log('Client disconnected:', socket.id);
    });
});

server.listen(3000, () => {
    console.log('Server running on http://localhost:3000');
});
```

### HTTP Server Best Practices

1. **Use Environment Variables**
```javascript
require('dotenv').config();

const PORT = process.env.PORT || 3000;
const DB_URL = process.env.DB_URL;
const SECRET_KEY = process.env.SECRET_KEY;
```

2. **Proper Error Handling**
```javascript
// Async error wrapper
const asyncHandler = (fn) => (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
};

app.get('/api/users', asyncHandler(async (req, res) => {
    const users = await User.find();
    res.json(users);
}));

// Global error handler
app.use((err, req, res, next) => {
    console.error(err.stack);
    
    res.status(err.statusCode || 500).json({
        error: err.message || 'Internal Server Error',
        ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    });
});
```

3. **Request Logging**
```javascript
const morgan = require('morgan');

// Development logging
app.use(morgan('dev'));

// Production logging to file
const fs = require('fs');
const path = require('path');

const accessLogStream = fs.createWriteStream(
    path.join(__dirname, 'access.log'),
    { flags: 'a' }
);

app.use(morgan('combined', { stream: accessLogStream }));
```

4. **Security Headers**
```javascript
const helmet = require('helmet');

app.use(helmet());

// Custom security headers
app.use((req, res, next) => {
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    next();
});
```

5. **Compression**
```javascript
const compression = require('compression');

app.use(compression());
```

6. **Graceful Shutdown**
```javascript
const server = app.listen(PORT);

process.on('SIGTERM', () => {
    console.log('SIGTERM signal received: closing HTTP server');
    server.close(() => {
        console.log('HTTP server closed');
        mongoose.connection.close(false, () => {
            console.log('MongoDB connection closed');
            process.exit(0);
        });
    });
});
```

---

## Interview Questions

### SQL vs NoSQL Questions

#### Basic Level

**Q1: What is the main difference between SQL and NoSQL databases?**
**A:** SQL databases are relational and use structured schemas with tables, while NoSQL databases are non-relational and use flexible, unstructured data models like documents, key-value pairs, or graphs.

**Q2: What does ACID stand for in SQL databases?**
**A:** 
- **A**tomicity: Transactions are all-or-nothing
- **C**onsistency: Database remains in valid state
- **I**solation: Concurrent transactions don't interfere
- **D**urability: Committed data persists

**Q3: When would you choose MongoDB over MySQL?**
**A:** Choose MongoDB when:
- Schema is likely to change frequently
- You need horizontal scaling
- Working with unstructured/semi-structured data
- Rapid development is priority
- You need high write throughput

Choose MySQL when:
- Complex queries and joins are required
- ACID compliance is critical
- Data has strong relationships
- Transactions are important (e.g., banking)

**Q4: What is a foreign key in SQL?**
**A:** A foreign key is a column (or set of columns) in one table that references the primary key in another table, establishing a relationship between the two tables and ensuring referential integrity.

**Q5: What are the types of NoSQL databases?**
**A:**
1. Document databases (MongoDB, CouchDB)
2. Key-value stores (Redis, DynamoDB)
3. Column-family stores (Cassandra, HBase)
4. Graph databases (Neo4j, ArangoDB)

#### Intermediate Level

**Q6: Explain normalization in SQL databases.**
**A:** Normalization is the process of organizing data to reduce redundancy and improve data integrity. It involves dividing large tables into smaller ones and defining relationships.
- **1NF**: Eliminate repeating groups, atomic values
- **2NF**: Remove partial dependencies
- **3NF**: Remove transitive dependencies
- **BCNF**: Every determinant is a candidate key

**Q7: What is the CAP theorem?**
**A:** CAP theorem states that a distributed database system can only guarantee two of these three properties:
- **C**onsistency: All nodes see the same data
- **A**vailability: Every request gets a response
- **P**artition tolerance: System continues despite network partitions

SQL databases typically choose CP, while NoSQL databases often choose AP.

**Q8: What is denormalization and when is it used?**
**A:** Denormalization is intentionally introducing redundancy to improve read performance by reducing the need for joins. Used when:
- Read performance is more critical than write performance
- Complex joins are expensive
- Data is read-heavy
- In NoSQL databases where joins aren't optimal

**Q9: Explain indexing in databases.**
**A:** Indexes are data structures that improve query performance by allowing faster data retrieval. They work like a book's index, creating pointers to data locations.
- **Pros**: Faster SELECT queries, faster sorting
- **Cons**: Slower INSERT/UPDATE/DELETE, additional storage space
- **Types**: B-tree, Hash, Bitmap, Full-text

**Q10: What is sharding?**
**A:** Sharding is horizontal partitioning where data is distributed across multiple servers/databases. Each shard contains a subset of the data, enabling horizontal scaling.
- **Range-based**: Data divided by ranges (e.g., A-M, N-Z)
- **Hash-based**: Data distributed using hash function
- **Geography-based**: Data divided by location

#### Advanced Level

**Q11: Compare vertical vs horizontal scaling.**
**A:**
**Vertical Scaling (Scale Up)**:
- Add more resources (CPU, RAM) to single server
- Simpler to implement
- Limited by hardware constraints
- Single point of failure
- Common in SQL databases

**Horizontal Scaling (Scale Out)**:
- Add more servers/nodes
- Complex to implement (requires data distribution)
- Virtually unlimited scaling
- Better fault tolerance
- Common in NoSQL databases

**Q12: Explain the N+1 query problem and its solution.**
**A:** N+1 problem occurs when fetching a list of items (1 query) and then fetching related data for each item (N queries).

Example:
```sql
-- 1 query to get users
SELECT * FROM users;

-- N queries (one per user)
SELECT * FROM orders WHERE user_id = 1;
SELECT * FROM orders WHERE user_id = 2;
-- ... for each user
```

**Solutions**:
- Use JOINs in SQL
- Use eager loading/population in ORM
- Batch queries
- Caching

**Q13: What is eventual consistency?**
**A:** Eventual consistency is a consistency model where, given enough time without new updates, all replicas will eventually converge to the same value. Used in distributed NoSQL systems (BASE model) to prioritize availability over immediate consistency. Example: Social media likes count might be temporarily inconsistent across servers.

**Q14: Explain database replication strategies.**
**A:**
**Master-Slave (Primary-Replica)**:
- One master (writes), multiple slaves (reads)
- Slaves replicate from master
- Read scaling, but write bottleneck

**Master-Master (Multi-Master)**:
- Multiple masters accept writes
- More complex conflict resolution
- Better write scalability

**Peer-to-Peer**:
- All nodes are equal
- High availability
- Complex consistency

**Q15: What are database transactions and isolation levels?**
**A:** Transactions are sequences of operations treated as a single unit.

**Isolation Levels** (SQL):
1. **Read Uncommitted**: Dirty reads possible
2. **Read Committed**: Only committed data visible
3. **Repeatable Read**: Same data read multiple times
4. **Serializable**: Complete isolation

Trade-off: Higher isolation = better consistency but lower concurrency

### ORM Questions

#### Basic Level

**Q16: What is ORM and why use it?**
**A:** ORM (Object-Relational Mapping) maps database tables to objects in code. Benefits include:
- Write less boilerplate code
- Database abstraction
- SQL injection protection
- Easier testing and maintenance
- Type safety in typed languages

**Q17: What are the disadvantages of using an ORM?**
**A:**
- Performance overhead
- Learning curve
- Complex queries can be harder
- May generate inefficient SQL
- Less control over exact query execution
- Can hide database operations
